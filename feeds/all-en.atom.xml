<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Titleless Sights</title><link href="http://james0zan.github.io/" rel="alternate"></link><link href="http://james0zan.github.io/feeds/all-en.atom.xml" rel="self"></link><id>http://james0zan.github.io/</id><updated>2013-05-02T00:00:00+08:00</updated><entry><title>All about Eve: Execute-Verify Replication for Multi-Core Servers @ OSDI'12</title><link href="http://james0zan.github.io/all-about-eve-execute-verify-replication-for-multi-core-servers-osdi12.html" rel="alternate"></link><updated>2013-05-02T00:00:00+08:00</updated><author><name>Mingxing Zhang</name></author><id>tag:james0zan.github.io,2013-05-02:all-about-eve-execute-verify-replication-for-multi-core-servers-osdi12.html</id><summary type="html">&lt;p&gt;&lt;em&gt;URL:&lt;/em&gt; &lt;a class="reference external" href="http://dl.acm.org/citation.cfm?id=2387903"&gt;http://dl.acm.org/citation.cfm?id=2387903&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://en.wikipedia.org/wiki/State_machine_replication"&gt;State machine replication (SMR)&lt;/a&gt; is a powerful fault tolerance technique, it enforces replicas to deterministically process the same
sequence of requests so that they produce the same sequence of outputs.&lt;/p&gt;
&lt;p&gt;But this technique doesn't suit for parallel systems, because if different servers interleave requests’ instructions in different ways, the states and outputs of correct servers may diverge even if no faults occur. As a result, most SMR systems require servers to process requests sequentially.&lt;/p&gt;
&lt;p&gt;In contrast, Eve partitions requests in batches and allows different replicas to execute requests within each batch in parallel. After each batch, it speculates that whether the results of these parallel executions (i.e. the system’s important state and output at each replica) will match across enough replicas.  If such a correct state/output can be identified, Eve makes those incorrect replicas issue an incremental state transfer request to other replicas (by leveraging  a &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Merkle_signature_scheme"&gt;Merkle tree&lt;/a&gt;). However, if too many replicas diverge so that the correct state/output cannot be identified, Eve guarantees safety and liveness by rolling back and sequentially and deterministically re-executing the requests.&lt;/p&gt;
&lt;p&gt;Since diverges will seriously impair Eve's performance, it uses a &lt;em&gt;mixer&lt;/em&gt; stage to apply
&lt;strong&gt;application-specific&lt;/strong&gt; criteria to produce groups of requests that are unlikely to interfere.&lt;/p&gt;
&lt;p&gt;As a side effect, Eve is especially useful in tolerating concurrency bugs. First, Eve’s
mixer reduces the likelihood of triggering latent concurrency bugs by attempting to run only unlikely-to-interfere requests in parallel; Second, Eve's execute-verify architecture allows Eve to detect and recover when concurrency causes executions to diverge.&lt;/p&gt;
&lt;p&gt;In their experiments, Eve achieves a 2.6x ~ 6.5x speedup over traditional sequential execution replica and at most 4.7x speedup over the &lt;a class="reference external" href="http://dl.acm.org/citation.cfm?id=1387601"&gt;Remus primary-backup system&lt;/a&gt;. It also finds new concurrency bugs in H2 database.&lt;/p&gt;
</summary><category term="replica"></category><category term="parallel"></category></entry><entry><title>Myth: Eric Brewer on Why Banks are BASE Not ACID - Availability Is Revenue</title><link href="http://james0zan.github.io/myth-eric-brewer-on-why-banks-are-base-not-acid-availability-is-revenue.html" rel="alternate"></link><updated>2013-05-02T00:00:00+08:00</updated><author><name>Mingxing Zhang</name></author><id>tag:james0zan.github.io,2013-05-02:myth-eric-brewer-on-why-banks-are-base-not-acid-availability-is-revenue.html</id><summary type="html">&lt;p&gt;&lt;em&gt;URL:&lt;/em&gt; &lt;a class="reference external" href="http://highscalability.com/blog/2013/5/1/myth-eric-brewer-on-why-banks-are-base-not-acid-availability.html"&gt;http://highscalability.com/blog/2013/5/1/myth-eric-brewer-on-why-banks-are-base-not-acid-availability.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A refutation of the myth, &amp;quot;Money is important, so banks must use transactions to keep money safe and consistent&amp;quot;.&lt;/p&gt;
&lt;p&gt;This fact sets the grounds of  Jeff Darcy's argument, &lt;a class="reference external" href="http://pl.atyp.us/wordpress/index.php/2013/03/is-eventual-consistency-useful"&gt;&amp;quot;Is Eventual Consistency Useful?&amp;quot;&lt;/a&gt;&lt;/p&gt;
</summary><category term="CAP"></category><category term="BASE"></category></entry><entry><title>Consistency Models Explained Briefly</title><link href="http://james0zan.github.io/consistency-models-explained-briefly.html" rel="alternate"></link><updated>2013-04-27T00:00:00+08:00</updated><author><name>Mingxing Zhang</name></author><id>tag:james0zan.github.io,2013-04-27:consistency-models-explained-briefly.html</id><summary type="html">&lt;p&gt;&lt;em&gt;URL:&lt;/em&gt; &lt;a class="reference external" href="http://coldattic.info/shvedsky/pro/blogs/a-foo-walks-into-a-bar/posts/88"&gt;http://coldattic.info/shvedsky/pro/blogs/a-foo-walks-into-a-bar/posts/88&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Consistency model, which describes how far the behavior of your multi-threaded (or distributed) system is from the ideal &amp;quot;sequential behavior&amp;quot;, belongs to the most important concepts of concurrency systems. But unfortunatly, discriptions about this topic are usually incomplete and even inconsistent with each other.&lt;/p&gt;
&lt;p&gt;This article, as its title indicates, clearly explains all the important consistency models with vivid diagrammatic presentations, which is well worth reading.&lt;/p&gt;
&lt;p&gt;Its main content is following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;Multithreading&amp;quot; Consistency Models&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Strong Consistency aka Linearizability&lt;/li&gt;
&lt;li&gt;Sequential Consistency&lt;/li&gt;
&lt;li&gt;Quiescent Consistency&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&amp;quot;Distributed&amp;quot; Consistency Models&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Eventual Consistency&lt;/li&gt;
&lt;li&gt;Strict Consistency&lt;/li&gt;
&lt;li&gt;Serializability&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><category term="consistency"></category></entry><entry><title>Welcome!</title><link href="http://james0zan.github.io/index.html.html" rel="alternate"></link><updated>2013-04-27T00:00:00+08:00</updated><author><name>Mingxing Zhang</name></author><id>tag:james0zan.github.io,2013-04-27:index.html.html</id><summary type="html">&lt;p&gt;Hello, I'm Mingxing Zhang a.k.a. james0zan.&lt;/p&gt;
&lt;p&gt;Currently, I am a 1st year Ph.D. student in &lt;a class="reference external" href="http://madsys.cs.tsinghua.edu.cn/en/"&gt;MadSys Group&lt;/a&gt; &amp;#64; Tsinghua University, and my research interests lie in distributed and parallel systems. You can refer to my &lt;a class="reference external" href="http://madsys.cs.tsinghua.edu.cn/~zhangmx/"&gt;homepage&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;Thank you for visiting. The blog is &lt;a class="reference external" href="category/blog.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
</summary></entry><entry><title>Parallel Merge Sort</title><link href="http://james0zan.github.io/parallel-merge-sort.html" rel="alternate"></link><updated>2013-04-27T00:00:00+08:00</updated><author><name>Mingxing Zhang</name></author><id>tag:james0zan.github.io,2013-04-27:parallel-merge-sort.html</id><summary type="html">&lt;p&gt;&lt;em&gt;URL:&lt;/em&gt; &lt;a class="reference external" href="http://coldattic.info/shvedsky/pro/blogs/a-foo-walks-into-a-bar/posts/49"&gt;http://coldattic.info/shvedsky/pro/blogs/a-foo-walks-into-a-bar/posts/49&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I used to think that the &amp;quot;merge&amp;quot; step of merge sort cannot be efficiently parallelized, because the fact that an element belongs to the tail of one sorted array could not even guarrantee that it won't rank first in the other sorted arrary.&lt;/p&gt;
&lt;p&gt;But this article illustrates that we can get across this obstacle by doing some binary search in advence.&lt;/p&gt;
&lt;p&gt;And even better, this algorithm preserves merges sort's ability to be a external sort.&lt;/p&gt;
</summary><category term="parallel"></category><category term="algorithm"></category></entry><entry><title>Start Blogging Now</title><link href="http://james0zan.github.io/start-blogging-now.html" rel="alternate"></link><updated>2013-04-27T00:00:00+08:00</updated><author><name>Mingxing Zhang</name></author><id>tag:james0zan.github.io,2013-04-27:start-blogging-now.html</id><summary type="html">&lt;p&gt;Inspired and encoraged by Nathan Marz's posts [&lt;a class="reference external" href="http://nathanmarz.com/blog/you-should-blog-even-if-you-have-no-readers.html"&gt;1&lt;/a&gt;, &lt;a class="reference external" href="http://nathanmarz.com/blog/break-into-silicon-valley-with-a-blog-1.html"&gt;2&lt;/a&gt;], I made the decision to restart my blog here.
But since I'm infected with procrastination to some extent, I may only share several interesting articles with my own comments under the &amp;quot;&lt;a class="reference external" href="http://james0zan.github.io/category/bookmark.html"&gt;Bookmark&lt;/a&gt;&amp;quot; column in the begining. I hope this will help me develop a habit of writing and sharing.&lt;/p&gt;
&lt;p&gt;Actually, I have already goten some articles under crafting, but I'm not sure when I can finish them ......&lt;/p&gt;
&lt;p&gt;Thank you for your reading, and I hope that I can see you again.&lt;/p&gt;
</summary><category term="journaling"></category></entry></feed>